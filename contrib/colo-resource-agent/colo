#!/usr/bin/env python3

# Resource agent for qemu COLO for use with Pacemaker CRM
#
# Copyright (c) Lukas Straub <lukasstraub2@web.de>
#
# This work is licensed under the terms of the GNU GPL, version 2 or
# later.  See the COPYING file in the top-level directory.

import subprocess
import sys
import os
import os.path
import signal
import socket
import select
import json
import re
import time
import logging
import logging.handlers
import traceback

# Constants
OCF_SUCCESS = 0
OCF_ERR_GENERIC = 1
OCF_ERR_ARGS = 2
OCF_ERR_UNIMPLEMENTED = 3
OCF_ERR_PERM = 4
OCF_ERR_INSTALLED = 5
OCF_ERR_CONFIGURED = 6
OCF_NOT_RUNNING = 7
OCF_RUNNING_MASTER = 8
OCF_FAILED_MASTER = 9

# Get environment variables
OCF_RESKEY_CRM_meta_notify_type = os.getenv("OCF_RESKEY_CRM_meta_notify_type")
OCF_RESKEY_CRM_meta_notify_operation = os.getenv("OCF_RESKEY_CRM_meta_notify_operation")
OCF_RESKEY_CRM_meta_notify_key_operation = os.getenv("OCF_RESKEY_CRM_meta_notify_key_operation")
OCF_RESKEY_CRM_meta_notify_start_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_start_uname", "")
OCF_RESKEY_CRM_meta_notify_stop_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_stop_uname", "")
OCF_RESKEY_CRM_meta_notify_active_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_active_uname", "")
OCF_RESKEY_CRM_meta_notify_promote_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_promote_uname", "")
OCF_RESKEY_CRM_meta_notify_demote_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_demote_uname", "")
OCF_RESKEY_CRM_meta_notify_master_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_master_uname", "")
OCF_RESKEY_CRM_meta_notify_slave_uname = os.getenv("OCF_RESKEY_CRM_meta_notify_slave_uname", "")

HA_RSCTMP = os.getenv("HA_RSCTMP", "/run/resource-agents")
HA_LOGFACILITY = os.getenv("HA_LOGFACILITY")
HA_LOGFILE = os.getenv("HA_LOGFILE")
HA_DEBUG = os.getenv("HA_debug", "0")
HA_DEBUGLOG = os.getenv("HA_DEBUGLOG")
OCF_RESOURCE_INSTANCE = os.getenv("OCF_RESOURCE_INSTANCE", "default-instance")
OCF_RESKEY_CRM_meta_timeout = int(os.getenv("OCF_RESKEY_CRM_meta_timeout", "60000"))
OCF_RESKEY_CRM_meta_interval = int(os.getenv("OCF_RESKEY_CRM_meta_interval", "1"))
OCF_RESKEY_CRM_meta_clone_max = int(os.getenv("OCF_RESKEY_CRM_meta_clone_max", "1"))
OCF_RESKEY_CRM_meta_clone_node_max = int(os.getenv("OCF_RESKEY_CRM_meta_clone_node_max", "1"))
OCF_RESKEY_CRM_meta_master_max = int(os.getenv("OCF_RESKEY_CRM_meta_master_max", "1"))
OCF_RESKEY_CRM_meta_master_node_max = int(os.getenv("OCF_RESKEY_CRM_meta_master_node_max", "1"))
OCF_RESKEY_CRM_meta_notify = os.getenv("OCF_RESKEY_CRM_meta_notify")
OCF_RESKEY_CRM_meta_globally_unique = os.getenv("OCF_RESKEY_CRM_meta_globally_unique")

HOSTNAME = os.getenv("OCF_RESKEY_CRM_meta_on_node", socket.gethostname())

OCF_ACTION = os.getenv("__OCF_ACTION")
if not OCF_ACTION and len(sys.argv) == 2:
    OCF_ACTION = sys.argv[1]

# Resource parameters
OCF_RESKEY_qemu_binary_default = "qemu-system-x86_64"
OCF_RESKEY_colod_binary_default = "colod"
OCF_RESKEY_qemu_img_binary_default = "qemu-img"
OCF_RESKEY_log_dir_default = HA_RSCTMP
OCF_RESKEY_options_default = ""
OCF_RESKEY_active_hidden_dir_default = ""
OCF_RESKEY_advanced_config_default = "{}"
OCF_RESKEY_listen_address_default = "0.0.0.0"
OCF_RESKEY_host_map_default = "{}"
OCF_RESKEY_base_port_default = "9000"
OCF_RESKEY_max_disk_errors_default = "1"
OCF_RESKEY_low_yank_timeout_default = "1000"
OCF_RESKEY_high_yank_timeout_default = "20000"
OCF_RESKEY_debug_default = "0"

OCF_RESKEY_qemu_binary = os.getenv("OCF_RESKEY_qemu_binary", OCF_RESKEY_qemu_binary_default)
OCF_RESKEY_colod_binary = os.getenv("OCF_RESKEY_colod_binary", OCF_RESKEY_colod_binary_default)
OCF_RESKEY_qemu_img_binary = os.getenv("OCF_RESKEY_qemu_img_binary", OCF_RESKEY_qemu_img_binary_default)
OCF_RESKEY_log_dir = os.getenv("OCF_RESKEY_log_dir", OCF_RESKEY_log_dir_default)
OCF_RESKEY_options = os.getenv("OCF_RESKEY_options", OCF_RESKEY_options_default)
OCF_RESKEY_active_hidden_dir = os.getenv("OCF_RESKEY_active_hidden_dir", OCF_RESKEY_active_hidden_dir_default)
OCF_RESKEY_advanced_config = os.getenv("OCF_RESKEY_advanced_config", OCF_RESKEY_advanced_config_default)
OCF_RESKEY_listen_address = os.getenv("OCF_RESKEY_listen_address", OCF_RESKEY_listen_address_default)
OCF_RESKEY_host_map = os.getenv("OCF_RESKEY_host_map", OCF_RESKEY_host_map_default)
OCF_RESKEY_base_port = os.getenv("OCF_RESKEY_base_port", OCF_RESKEY_base_port_default)
OCF_RESKEY_max_disk_errors = os.getenv("OCF_RESKEY_max_disk_errors", OCF_RESKEY_max_disk_errors_default)
OCF_RESKEY_low_yank_timeout = os.getenv("OCF_RESKEY_low_yank_timeout", OCF_RESKEY_low_yank_timeout_default)
OCF_RESKEY_high_yank_timeout = os.getenv("OCF_RESKEY_high_yank_timeout", OCF_RESKEY_high_yank_timeout_default)
OCF_RESKEY_debug = os.getenv("OCF_RESKEY_debug", OCF_RESKEY_debug_default)

ACTIVE_IMAGE = os.path.join(OCF_RESKEY_active_hidden_dir, \
                            OCF_RESOURCE_INSTANCE + "-active.qcow2")
HIDDEN_IMAGE = os.path.join(OCF_RESKEY_active_hidden_dir, \
                            OCF_RESOURCE_INSTANCE + "-hidden.qcow2")

BASE_DIR = os.path.join(HA_RSCTMP, OCF_RESOURCE_INSTANCE)
QMP_SOCK = os.path.join(BASE_DIR, "qmp.sock")
QMP_YANK_SOCK = os.path.join(BASE_DIR, "qmp-yank.sock")
HELPER_SOCK = os.path.join(BASE_DIR, "colod.sock")
COMP_PRI_SOCK = os.path.join(BASE_DIR, "comp-pri-in0.sock")
COMP_OUT_SOCK = os.path.join(BASE_DIR, "comp-out0.sock")

QEMU_PIDFILE = os.path.join(BASE_DIR, "qemu.pid")
COLOD_PIDFILE = os.path.join(BASE_DIR, "colod.pid")

QMP_LOG = os.path.join(OCF_RESKEY_log_dir, OCF_RESOURCE_INSTANCE + "-qmp.log")
QEMU_LOG = os.path.join(OCF_RESKEY_log_dir, OCF_RESOURCE_INSTANCE + "-qemu.log")
HELPER_LOG = os.path.join(OCF_RESKEY_log_dir, OCF_RESOURCE_INSTANCE \
                                                                + "-helper.log")

START_TIME = time.time()

# Exception only raised by ourself
class Error(Exception):
    pass

def nbd_port():
    return int(OCF_RESKEY_base_port)

def migrate_port():
    return int(OCF_RESKEY_base_port) + 1

def mirror_port():
    return int(OCF_RESKEY_base_port) + 2

def compare_in_port():
    return int(OCF_RESKEY_base_port) + 3

def common_cmdline():
    return \
        (" -no-shutdown -daemonize -D '%(QEMU_LOG)s'"
        " -pidfile '%(QEMU_PIDFILE)s'"
        " -qmp unix:'%(QMP_SOCK)s',server=on,wait=off"
        " -qmp unix:'%(QMP_YANK_SOCK)s',server=on,wait=off"
        " -object throttle-group,id=throttle0") % globals()

def qemu_primary_cmdline(config):
    cmdline = \
        ("'%s' %s"
        " -drive if=none,node-name=quorum0,driver=quorum,"
        "read-pattern=fifo,vote-threshold=1,children.0=parent0"
        " -drive if=none,node-name=colo-disk0,driver=throttle,"
        "throttle-group=throttle0,file.driver=raw,file.file=quorum0") \
        % (OCF_RESKEY_qemu_binary, config["qemu-options-str"])

    cmdline += common_cmdline()

    return cmdline

def qemu_secondary_cmdline(config):
    listen_address = OCF_RESKEY_listen_address
    cmdline = \
        ("'%s' %s"
        " -chardev socket,id=mirror0,host='%s',port=%s,"
        "server=on,wait=off,nodelay=on"
        " -chardev socket,id=comp_sec_in0,host='%s',port=%s,"
        "server=on,wait=off,nodelay=on"
        " -object filter-redirector,id=mirror0,netdev=hn0,queue=tx,"
        "indev=mirror0"
        " -object filter-redirector,id=comp_sec_in0,netdev=hn0,queue=rx,"
        "outdev=comp_sec_in0") \
        % (OCF_RESKEY_qemu_binary, config["qemu-options-str"],
            listen_address, mirror_port(),
            listen_address, compare_in_port())

    if config["filter-rewriter"]:
        cmdline += " -object filter-rewriter,id=rew0,netdev=hn0,queue=all"

    cmdline += \
        (" -drive if=none,node-name=childs0,top-id=colo-disk0,"
        "driver=replication,mode=secondary,file.driver=qcow2,"
        "file.file.filename='%s',"
        "file.backing.driver=qcow2,file.backing.file.filename='%s',"
        "file.backing.backing=parent0"
        " -drive if=none,node-name=quorum0,driver=quorum,"
        "read-pattern=fifo,vote-threshold=1,children.0=childs0"
        " -drive if=none,node-name=colo-disk0,driver=throttle,"
        "throttle-group=throttle0,file.driver=raw,"
        "file.file=quorum0"
        " -incoming defer") \
        % (ACTIVE_IMAGE, HIDDEN_IMAGE)

    cmdline += common_cmdline()

    return cmdline

def qemu_dummy_cmdline(config):
    cmdline = \
        ("'%s' %s -drive if=none,node-name=colo-disk0,driver=null-co -S") \
        % (OCF_RESKEY_qemu_binary, config["qemu-options-str"])

    cmdline += common_cmdline()

    return cmdline

def colod_cmdline():
    cmdline = \
        ("'%(OCF_RESKEY_colod_binary)s' -ds"
        " -i '%(OCF_RESOURCE_INSTANCE)s' -n '%(HOSTNAME)s'"
        " -b '%(BASE_DIR)s' -q '%(QMP_SOCK)s' -y '%(QMP_YANK_SOCK)s'"
        " -l %(OCF_RESKEY_low_yank_timeout)s"
        " -t %(OCF_RESKEY_high_yank_timeout)s") % globals()

    if int(OCF_RESKEY_debug) >= 1:
        cmdline += " --trace"

    return cmdline

def qemu_colo_meta_data():
    print("""\
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="colo">

    <version>1.0</version>
    <longdesc lang="en">
Resource agent for qemu COLO. (https://wiki.qemu.org/Features/COLO)

After defining the master/slave instance, the master score has to be
manually set to show which node has up-to-date data. So you copy your
image to one host (and create empty images the other host(s)) and then
run "crm_master -r name_of_your_primitive -v 10" on that host.
Also, you have to set 'notify=true' in the metadata attributes when
defining the primary/secondary instance.

Note:
-If the instance is stopped cluster-wide, the resource agent will do a
clean shutdown. Set the demote timeout to the time it takes for your
guest to shutdown.
-The resource agent may notify pacemaker about peer failure,
these failures will show up with exitreason="Simulated failure".
    </longdesc>
    <shortdesc lang="en">Qemu COLO</shortdesc>

    <parameters>

    <parameter name="qemu_binary" unique="0" required="0">
        <longdesc lang="en">qemu binary to use</longdesc>
        <shortdesc lang="en">qemu binary</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_qemu_binary_default + """\"/>
    </parameter>

    <parameter name="colod_binary" unique="0" required="0">
        <longdesc lang="en">colod binary to use</longdesc>
        <shortdesc lang="en">colod binary</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_colod_binary_default + """\"/>
    </parameter>

    <parameter name="qemu_img_binary" unique="0" required="0">
        <longdesc lang="en">qemu-img binary to use</longdesc>
        <shortdesc lang="en">qemu-img binary</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_qemu_img_binary_default + """\"/>
    </parameter>

    <parameter name="log_dir" unique="0" required="0">
        <longdesc lang="en">Directory to place logs in</longdesc>
        <shortdesc lang="en">Log directory</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_log_dir_default + """\"/>
    </parameter>

    <parameter name="options" unique="0" required="0">
        <longdesc lang="en">
Options to pass to qemu. These will be passed alongside COLO specific
options, so you need to follow these conventions: The netdev should have
id=hn0 and the disk controller drive=colo-disk0. The image node should
have node-name=parent0, but should not be connected to the guest.
Example:
-vnc :0 -enable-kvm -cpu qemu64,+kvmclock -m 512 -netdev bridge,id=hn0
-device e1000,netdev=hn0 -device virtio-blk,drive=colo-disk0
-drive if=none,node-name=parent0,format=qcow2,file=/mnt/vms/vm01.qcow2
        </longdesc>
        <shortdesc lang="en">Options to pass to qemu.</shortdesc>
    </parameter>

    <parameter name="active_hidden_dir" unique="0" required="1">
        <longdesc lang="en">
Directory where the active and hidden images will be stored. It is
recommended to put this on a ramdisk.
        </longdesc>
        <shortdesc lang="en">Path to active and hidden images</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_active_hidden_dir_default + """\"/>
    </parameter>

    <parameter name="advanced_config" unique="0" required="0">
        <shortdesc lang="en">Advanced config options</shortdesc>
        <longdesc lang="en">
Json object containing advanced configuration options.

If the object contains a "include" member, it's value is parsed as a
file name. The file is parsed as a json object which is then updated
with values of the current object e.g. values of the current object
take precedence over the values of the included object.
The file may contain another "include" member, which is parsed
recursively.

If "qemu-options-str" is configured here, it takes precedence over the
"options" parameter to the resource-agent.
"qemu-options-str" may be a list of strings, which will be concatenated.

Consult the qemu qmp documentation for more information at
https://www.qemu.org/docs/master/interop/qemu-qmp-ref.html

Example using a config file:
    advanced_config='{"include": "/etc/debian_vm.json"}'

/etc/debian_vm.json:
{
    "qemu-options-str": [
        " -vnc :0 -enable-kvm -cpu qemu64,+kvmclock -m 2048",
        " -netdev bridge,id=hn0 -device e1000,netdev=hn0",
        " -device virtio-blk,drive=colo-disk0",
        " -drive if=none,node-name=parent0,format=qcow2,",
        "file=/mnt/vms/debian_vm.qcow2"
    ],
    "vnet-hdr": false,
    "filter-rewriter": true,
    "colo-compare-options": {"expired_scan_cycle": 100},
    "migration-parameters": {"multifd-channels": 4},
    "migration-capabilities": [{"capability": "multifd", "state": true}],
    "throttle-limits": {"bps-read": 104857600, "bps-write": 104857600}
}
        </longdesc>
        <content type="string" default=\"""" + OCF_RESKEY_advanced_config_default + """\"/>
    </parameter>

    <parameter name="listen_address" unique="0" required="0">
        <longdesc lang="en">Address to listen on.</longdesc>
        <shortdesc lang="en">Listen address</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_listen_address_default + """\"/>
    </parameter>

    <parameter name="host_map" unique="0" required="0">
        <longdesc lang="en">
Map each host to a ip address to use for replication. Must be a valid json object.
Example:
{"node1": "192.168.222.10", "node2": "192.168.222.11"}
        </longdesc>
        <shortdesc lang="en">Host map</shortdesc>
        <content type="string" default=\"""" + OCF_RESKEY_host_map_default + """\"/>
    </parameter>

    <parameter name="base_port" unique="1" required="0">
        <longdesc lang="en">
4 tcp ports that are unique for each instance. (base_port to base_port + 3)
        </longdesc>
        <shortdesc lang="en">Ports to use</shortdesc>
        <content type="integer" default=\"""" + OCF_RESKEY_base_port_default + """\"/>
    </parameter>

    <parameter name="max_disk_errors" unique="0" required="0">
        <longdesc lang="en">
Maximum disk read errors per monitor interval before marking the resource
as failed. A write error is always fatal except if the value is 0.
A value of 0 will disable disk error handling.
Primary disk errors are only handled if there is a healthy secondary.
        </longdesc>
        <shortdesc lang="en">Maximum disk errors</shortdesc>
        <content type="integer" default=\"""" + OCF_RESKEY_max_disk_errors_default + """\"/>
    </parameter>

    <parameter name="low_yank_timeout" unique="0" required="0">
        <longdesc lang="en">
Timeout for QMP commands after which to execute the "yank" command,
in milliseconds.
Must be lower than any of the action timeouts.
        </longdesc>
        <shortdesc lang="en">Low yank timeout</shortdesc>
        <content type="integer" default=\"""" + OCF_RESKEY_low_yank_timeout_default + """\"/>
    </parameter>

    <parameter name="high_yank_timeout" unique="0" required="0">
        <longdesc lang="en">
Timeout for QMP commands after which to execute the "yank" command,
in milliseconds.
Must be lower than any of the action timeouts.
Used during critical sections where the qemu mainloop will be blocked
longer than usual.
        </longdesc>
        <shortdesc lang="en">High yank timeout</shortdesc>
        <content type="integer" default=\"""" + OCF_RESKEY_high_yank_timeout_default + """\"/>
    </parameter>

    <parameter name="debug" unique="0" required="0">
        <longdesc lang="en">
Control debugging:
0: disable debugging
1: log debug messages and qmp commands
2: + dump core of hanging qemu
        </longdesc>
        <shortdesc lang="en">Control debugging</shortdesc>
        <content type="integer" default=\"""" + OCF_RESKEY_debug_default + """\"/>
    </parameter>

    </parameters>

    <actions>
        <action name="start"        timeout="30s" />
        <action name="stop"         timeout="10s" />
        <action name="monitor"      timeout="30s" \
            interval="1000ms" depth="0" role="Slave" />
        <action name="monitor"      timeout="30s" \
            interval="1001ms" depth="0" role="Master" />
        <action name="notify"       timeout="30s" />
        <action name="promote"      timeout="30s" />
        <action name="demote"       timeout="120s" />
        <action name="meta-data"    timeout="5s" />
        <action name="validate-all" timeout="30s" />
    </actions>

</resource-agent>
""")

def check_config(config):
    if not isinstance(config["qemu-options-str"], str):
        log.error("advanced_config: qemu-options-str needs to be a string "
                  "or an array of strings")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["vnet-hdr"], bool):
        log.error("advanced_config: vnet-hdr needs to be a bool")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["filter-rewriter"], bool):
        log.error("advanced_config: filter-rewriter needs to be a bool")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["colo-compare-options"], dict):
        log.error("advanced_config: colo-compare-options needs to be an object")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["migration-parameters"], dict):
        log.error("advanced_config: migration-parameters needs to be an object")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["migration-capabilities"], list):
        log.error("advanced_config: migration-capabilities needs to be an array")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["throttle-limits"], dict):
        log.error("advanced_config: throttle-limits needs to be an object")
        return OCF_ERR_CONFIGURED

    if not isinstance(config["blockdev-mirror-arguments"], dict):
        log.error("advanced_config: blockdev-mirror-arguments needs to be "
                  "an object")
        return OCF_ERR_CONFIGURED

    return OCF_SUCCESS

def _parse_config(config_str):
    parsed = json.loads(config_str)

    if "include" in parsed:
        with open(parsed["include"], "r") as fd:
            include_str = fd.read()

        include = _parse_config(include_str)
        include.update(parsed)
        return include

    return parsed

def parse_config(config_str):
    config = {
        "qemu-options-str": OCF_RESKEY_options,
        "vnet-hdr": False,
        "filter-rewriter": True,
        "colo-compare-options": {},
        "migration-parameters": {},
        "migration-capabilities": [],
        "throttle-limits": {},
        "blockdev-mirror-arguments": {}
    }

    parsed = _parse_config(config_str)
    config.update(parsed)

    qemu_options = config["qemu-options-str"]
    if isinstance(qemu_options, list):
        config["qemu-options-str"] = "".join(qemu_options)

    return config

# Sanity checks: check parameters, files, binaries, etc.
def qemu_colo_validate_all():
    # Check resource parameters
    if not str.isdigit(OCF_RESKEY_base_port):
        log.error("base_port needs to be a number")
        return OCF_ERR_CONFIGURED

    if not str.isdigit(OCF_RESKEY_max_disk_errors):
        log.error("max_disk_errors needs to be a number")
        return OCF_ERR_CONFIGURED

    if not str.isdigit(OCF_RESKEY_low_yank_timeout):
        log.error("low_yank_timeout needs to be a number")
        return OCF_ERR_CONFIGURED

    if not str.isdigit(OCF_RESKEY_high_yank_timeout):
        log.error("high_yank_timeout needs to be a number")
        return OCF_ERR_CONFIGURED

    if not str.isdigit(OCF_RESKEY_debug):
        log.error("debug needs to be a number")
        return OCF_ERR_CONFIGURED

    if not OCF_RESKEY_active_hidden_dir:
        log.error("active_hidden_dir needs to be specified")
        return OCF_ERR_CONFIGURED

    try:
        config = parse_config(OCF_RESKEY_advanced_config)
    except Exception as e:
        log.error("Failed parsing advanced_config: %s" % str(e))

    result = check_config(config)
    if result != OCF_SUCCESS:
        return result

    try:
        json.loads(OCF_RESKEY_host_map)
    except Exception as e:
        log.error("host_map is not valid json: %s" % str(e))

    # Check resource meta configuration
    if OCF_ACTION != "stop":
        if OCF_RESKEY_CRM_meta_master_max != 1:
            log.error("only one master allowed")
            return OCF_ERR_CONFIGURED

        if OCF_RESKEY_CRM_meta_clone_max > 2:
            log.error("maximum 2 clones allowed")
            return OCF_ERR_CONFIGURED

        if OCF_RESKEY_CRM_meta_master_node_max != 1:
            log.error("only one master per node allowed")
            return OCF_ERR_CONFIGURED

        if OCF_RESKEY_CRM_meta_clone_node_max != 1:
            log.error("only one clone per node allowed")
            return OCF_ERR_CONFIGURED

    # Check if notify is enabled
    if OCF_ACTION != "stop" and OCF_ACTION != "monitor":
        if not is_true(OCF_RESKEY_CRM_meta_notify) \
           and not OCF_RESKEY_CRM_meta_notify_start_uname:
            log.error("notify needs to be enabled")
            return OCF_ERR_CONFIGURED

    # Check that globally-unique is disabled
    if is_true(OCF_RESKEY_CRM_meta_globally_unique):
        log.error("globally-unique needs to be disabled")
        return OCF_ERR_CONFIGURED

    # Check binaries
    if not check_binary(OCF_RESKEY_qemu_binary):
        return OCF_ERR_INSTALLED

    if not check_binary(OCF_RESKEY_colod_binary):
        return OCF_ERR_INSTALLED

    if not check_binary(OCF_RESKEY_qemu_img_binary):
        return OCF_ERR_INSTALLED

    # Check paths and files
    if not is_writable(OCF_RESKEY_active_hidden_dir) \
        or not os.path.isdir(OCF_RESKEY_active_hidden_dir):
        log.error("active and hidden image directory missing or not writable")
        return OCF_ERR_PERM

    return OCF_SUCCESS

def logs_open():
    global log
    log = logging.getLogger(OCF_RESOURCE_INSTANCE)
    if int(OCF_RESKEY_debug) >= 1 or HA_DEBUG != "0":
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    formater = logging.Formatter("(%(name)s) %(levelname)s: %(message)s")

    if sys.stdout.isatty():
        handler = logging.StreamHandler(stream=sys.stderr)
        handler.setFormatter(formater)
        log.addHandler(handler)

    if HA_LOGFACILITY:
        handler = logging.handlers.SysLogHandler("/dev/log")
        handler.setFormatter(formater)
        log.addHandler(handler)

    if HA_LOGFILE:
        handler = logging.FileHandler(HA_LOGFILE)
        handler.setFormatter(formater)
        log.addHandler(handler)

    if HA_DEBUGLOG and HA_DEBUGLOG != HA_LOGFILE:
        handler = logging.FileHandler(HA_DEBUGLOG)
        handler.setFormatter(formater)
        log.addHandler(handler)

def rotate_logfile(logfile, numlogs):
    numlogs -= 1
    for n in range(numlogs, -1, -1):
        _file = logfile
        if n != 0:
            _file = "%s.%s" % (_file, n)
        if os.path.exists(_file):
            if n == numlogs:
                os.remove(_file)
            else:
                newname = "%s.%s" % (logfile, n + 1)
                os.rename(_file, newname)

def is_writable(_file):
    return os.access(_file, os.W_OK)

def is_executable_file(_file):
    return os.path.isfile(_file) and os.access(_file, os.X_OK)

def is_true(var):
    return re.match("yes|true|1|YES|TRUE|True|ja|on|ON", str(var)) != None

# Check if the binary exists and is executable
def check_binary(binary):
    if is_executable_file(binary):
        return True
    PATH = os.getenv("PATH", os.defpath)
    for _dir in PATH.split(os.pathsep):
        if is_executable_file(os.path.join(_dir, binary)):
            return True
    log.error("binary \"%s\" doesn't exist or not executable" % binary)
    return False

def run_command(commandline):
    proc = subprocess.Popen(commandline, shell=True, stdout=subprocess.PIPE,
                          stderr=subprocess.STDOUT, universal_newlines=True)
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        log.error("command \"%s\" failed with code %s:\n%s" \
                    % (commandline, proc.returncode, stdout))
        raise Error()

# Functions for setting and getting the master score to tell Pacemaker which
# host has the most recent data
def set_master_score(score):
    if score == 0:
        run_command("crm_master -q -l forever -D")
    else:
        run_command("crm_master -q -l forever -v %s" % score)

def set_remote_master_score(remote, score):
    if score == 0:
        run_command("crm_master -q -l forever -N '%s' -D" % remote)
    else:
        run_command("crm_master -q -l forever -N '%s' -v %s" % (remote, score))

def get_master_score():
    proc = subprocess.Popen("crm_master -q -G", shell=True,
                            stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                            universal_newlines=True)
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        return 0
    else:
        return int(str.strip(stdout))

def get_remote_master_score(remote):
    proc = subprocess.Popen("crm_master -q -N '%s' -G" % remote, shell=True,
                            stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                            universal_newlines=True)
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        return 0
    else:
        return int(str.strip(stdout))

# Tell Pacemaker that the remote resource failed
def report_remote_failure(remote):
    try:
        run_command("crm_resource --resource '%s' --fail --node '%s'"
                    % (OCF_RESOURCE_INSTANCE, remote))
    except Exception as e:
        log.error(str(e));

def recv_line(fd):
    line = b''
    while True:
        tmp = fd.recv(1)
        line += tmp
        if tmp == b'\n' or len(tmp) == 0:
            break
    return line.decode()

def read_answer(fd):
    line = recv_line(fd)

    if len(line) == 0:
        log.error("qmp connection closed")
        raise Error()

    return json.loads(line)

# Execute one or more qmp commands
def qmp_execute(fd, commands, ignore_error = False):
    for command in commands:
        if not command:
            continue

        to_send = json.dumps(command)
        fd.sendall(str.encode(to_send + "\n"))

        answer = read_answer(fd)

        if not ignore_error and ("error" in answer):
            log.error("qmp command returned error:\n%s\n%s" \
                        % (json.dumps(command), json.dumps(answer)))
            raise Error()

    return answer

# Open qemu qmp connection
def qmp_open():
    timeout = OCF_RESKEY_CRM_meta_timeout*2/3/1000

    try:
        fd = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        fd.settimeout(timeout)
        fd.connect(HELPER_SOCK)
    except socket.error as e:
        log.error("while connecting to helper socket: %s" % e)
        raise Error()

    return fd

def map_host(remote):
    host_map = json.loads(OCF_RESKEY_host_map)
    if remote in host_map:
        return host_map[remote]
    else:
        return remote

# Get the disk size of the (user supplied) parent disk
def qmp_get_disk_size(fd):
    block_nodes = qmp_execute(fd, [{"execute": "query-named-block-nodes", "arguments": {"flat": True}}])
    for node in block_nodes["return"]:
        if node["node-name"] == "parent0":
            return node["image"]["virtual-size"]

    log.error("Disk \"parent0\" not found")
    raise Error()

# Get the host of the nbd node
def qmp_get_nbd_remote(fd):
    block_nodes = qmp_execute(fd, [{"execute": "query-named-block-nodes", "arguments": {"flat": True}}])
    for node in block_nodes["return"]:
        if node["node-name"] == "nbd0":
            url = str(node["image"]["filename"])
            return str.split(url, "//")[1].split("/")[0].split(":")[0]
    return None

# Check if we are currently resyncing
def qmp_check_resync(fd):
    answer = qmp_execute(fd, [{"execute": "query-block-jobs"}])
    for job in answer["return"]:
        if job["device"] == "resync":
            return job
    return None

def qmp_start_resync(fd, peer):
    config = parse_config(OCF_RESKEY_advanced_config)
    ip = map_host(peer)

    answer = qmp_execute(fd, [{"execute": "blockdev-add", "arguments": {"driver": "nbd", "node-name": "nbd0", "server": {"type": "inet", "host": str(ip), "port": str(nbd_port())}, "export": "parent0", "detect-zeroes": "on"}}], ignore_error = True)
    if "error" in answer:
        log.warning("Failed to add nbd node: %s" % json.dumps(answer))
        log.warning("Assuming peer failure")
        report_remote_failure(peer)
    else:
        blockdev_mirror_arguments = {"device": "colo-disk0", "job-id": "resync", "target": "nbd0", "sync": "full", "on-target-error": "report", "on-source-error": "ignore", "auto-dismiss": False}
        blockdev_mirror_arguments.update(config["blockdev-mirror-arguments"])
        qmp_execute(fd, [{"execute": "blockdev-mirror", "arguments": blockdev_mirror_arguments}])

def qmp_cancel_resync(fd):
    timeout = START_TIME + (OCF_RESKEY_CRM_meta_timeout*1/2/1000)

    if qmp_check_resync(fd)["status"] != "concluded":
        qmp_execute(fd, [{"execute": "block-job-cancel", "arguments": {"device": "resync", "force": True}}], ignore_error = True)
        # Wait for the block-job to finish
        while time.time() < timeout:
            if qmp_check_resync(fd)["status"] == "concluded":
                break
            log.debug("Waiting for block-job to finish in qmp_cancel_resync()")
            time.sleep(1)
        else:
            log.warning("Timed out, trying to unfreeze qemu")
            qmp_execute(fd, [{"exec-colod": "yank"}])
            while qmp_check_resync(fd)["status"] != "concluded":
                log.debug("Waiting for block-job to finish")
                time.sleep(1)

    qmp_execute(fd, [
        {"execute": "block-job-dismiss", "arguments": {"id": "resync"}},
        {"execute": "blockdev-del", "arguments": {"node-name": "nbd0"}}
        ])

def qmp_setup_colod(fd):
    qmp_update_store(fd, {"peer": None, "pretend-secondary": False})

    qmp_execute(fd, [
        {"exec-colod": "set-yank", "instances": [
            {"type": "block-node", "node-name": "nbd0"},
            {"type": "chardev", "id": "mirror0"},
            {"type": "chardev", "id": "comp_sec_in0"},
            {"type": "migration"}]},

        {"exec-colod": "set-migration", "commands": [
            {"execute": "qom-set", "arguments": {"path": "/objects/mirror0", "property": "status", "value": "on"}},
            {"execute": "qom-set", "arguments": {"path": "/objects/comp_pri_in0", "property": "status", "value": "on"}}]},

        {"exec-colod": "set-primary-failover", "commands": [
            {"execute": "qom-set", "arguments": {"path": "/objects/mirror0", "property": "status", "value": "off"}},
            {"execute": "qom-set", "arguments": {"path": "/objects/comp_pri_in0", "property": "status", "value": "off"}},
            {"execute": "x-blockdev-change", "arguments": {"parent": "quorum0", "child": "children.1"}},
            {"execute": "x-colo-lost-heartbeat"},
            {"execute": "blockdev-del", "arguments": {"node-name": "nbd0"}},
            {"execute": "object-del", "arguments": {"id": "mirror0"}},
            {"execute": "object-del", "arguments": {"id": "comp_pri_in0"}},
            {"execute": "object-del", "arguments": {"id": "comp_out0"}},
            {"execute": "object-del", "arguments": {"id": "comp0"}},
            {"execute": "object-del", "arguments": {"id": "iothread1"}},
            {"execute": "chardev-remove", "arguments": {"id": "mirror0"}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_sec_in0"}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_pri_in0.."}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_pri_in0"}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_out0.."}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_out0"}}]},

        {"exec-colod": "set-secondary-failover", "commands": [
            {"execute": "qom-set", "arguments": {"path": "/objects/comp_sec_in0", "property": "status", "value": "off"}},
            {"execute": "nbd-server-stop"},
            {"execute": "x-colo-lost-heartbeat"},
            {"execute": "object-del", "arguments": {"id": "mirror0"}},
            {"execute": "object-del", "arguments": {"id": "comp_sec_in0"}},
            {"execute": "chardev-remove", "arguments": {"id": "mirror0"}},
            {"execute": "chardev-remove", "arguments": {"id": "comp_sec_in0"}}]}
    ])

def qmp_throttle_settings(fd, config):
    qmp_execute(fd, [
        {"execute": "qom-set", "arguments": {"path": "/objects/throttle0", "property": "limits", "value": config["throttle-limits"]}}
        ])

def qmp_migrate_settings(fd, config):
    qmp_execute(fd, [
        {"execute": "migrate-set-capabilities", "arguments": {"capabilities": [{"capability": "x-colo", "state": True}]}},
        {"execute": "migrate-set-capabilities", "arguments": {"capabilities": config["migration-capabilities"]}},
        {"execute": "migrate-set-parameters", "arguments": config["migration-parameters"]}
    ])

def qmp_start_migration(fd, peer):
    config = parse_config(OCF_RESKEY_advanced_config)
    ip = map_host(peer)

    # Check if we have a filter-rewriter
    answer = qmp_execute(fd, [{"execute": "qom-list", "arguments": {"path": "/objects/rew0"}}], ignore_error = True)
    if "error" in answer:
        if answer["error"]["class"] == "DeviceNotFound":
            have_filter_rewriter = False
        else:
            log.error("While checking for filter-rewriter:\n%s" \
                        % json.dumps(answer))
            raise Error()
    else:
        have_filter_rewriter = True

    # Pause VM and cancel resync
    qmp_execute(fd, [
        {"exec-colod": "stop"},
        {"execute": "block-job-cancel", "arguments": {"device": "resync"}}
        ])

    # Wait for the block-job to finish
    while qmp_check_resync(fd)["status"] != "concluded":
        log.debug("Waiting for block-job to finish in qmp_start_migration()")
        time.sleep(1)

    # Add nbd to the quorum node
    qmp_execute(fd, [
        {"execute": "block-job-dismiss", "arguments": {"id": "resync"}},
        {"execute": "x-blockdev-change", "arguments": {"parent": "quorum0", "node": "nbd0"}},
        {"exec-colod": "cont"}
        ])

    # Connect mirror and compare_in to secondary
    qmp_execute(fd, [
        {"execute": "chardev-add", "arguments": {"id": "comp_pri_in0..", "backend": {"type": "socket", "data": {"addr": {"type": "unix", "data": {"path": str(COMP_PRI_SOCK)}}, "server": True}}}},
        {"execute": "chardev-add", "arguments": {"id": "comp_pri_in0", "backend": {"type": "socket", "data": {"addr": {"type": "unix", "data": {"path": str(COMP_PRI_SOCK)}}, "server": False}}}},
        {"execute": "chardev-add", "arguments": {"id": "comp_out0..", "backend": {"type": "socket", "data": {"addr": {"type": "unix", "data": {"path": str(COMP_OUT_SOCK)}}, "server": True}}}},
        {"execute": "chardev-add", "arguments": {"id": "comp_out0", "backend": {"type": "socket", "data": {"addr": {"type": "unix", "data": {"path": str(COMP_OUT_SOCK)}}, "server": False}}}},
        {"execute": "chardev-add", "arguments": {"id": "mirror0", "backend": {"type": "socket", "data": {"addr": {"type": "inet", "data": {"host": str(ip), "port": str(mirror_port())}}, "server": False, "nodelay": True }}}},
        {"execute": "chardev-add", "arguments": {"id": "comp_sec_in0", "backend": {"type": "socket", "data": {"addr": {"type": "inet", "data": {"host": str(ip), "port": str(compare_in_port())}}, "server": False, "nodelay": True }}}}
        ])

    # Add the COLO filters
    vnet_hdr_support = config["vnet-hdr"]
    if have_filter_rewriter:
        qmp_execute(fd, [
            {"execute": "object-add", "arguments": {"qom-type": "filter-mirror", "id": "mirror0", "status": "off", "insert": "before", "position": "id=rew0", "netdev": "hn0", "queue": "tx", "outdev": "mirror0", "vnet_hdr_support": vnet_hdr_support}},
            {"execute": "object-add", "arguments": {"qom-type": "filter-redirector", "id": "comp_out0", "insert": "before", "position": "id=rew0", "netdev": "hn0", "queue": "rx", "indev": "comp_out0..", "vnet_hdr_support": vnet_hdr_support}},
            {"execute": "object-add", "arguments": {"qom-type": "filter-redirector", "id": "comp_pri_in0", "status": "off", "insert": "before", "position": "id=rew0", "netdev": "hn0", "queue": "rx", "outdev": "comp_pri_in0..", "vnet_hdr_support": vnet_hdr_support}}
            ])
    else:
        qmp_execute(fd, [
            {"execute": "object-add", "arguments": {"qom-type": "filter-mirror", "id": "mirror0", "status": "off", "netdev": "hn0", "queue": "tx", "outdev": "mirror0", "vnet_hdr_support": vnet_hdr_support}},
            {"execute": "object-add", "arguments": {"qom-type": "filter-redirector", "id": "comp_out0", "netdev": "hn0", "queue": "rx", "indev": "comp_out0..", "vnet_hdr_support": vnet_hdr_support}},
            {"execute": "object-add", "arguments": {"qom-type": "filter-redirector", "id": "comp_pri_in0", "status": "off", "netdev": "hn0", "queue": "rx", "outdev": "comp_pri_in0..", "vnet_hdr_support": vnet_hdr_support}}
            ])

    colo_compare_options = config["colo-compare-options"]
    colo_compare_arguments = {"qom-type": "colo-compare", "id": "comp0", "primary_in": "comp_pri_in0", "secondary_in": "comp_sec_in0", "outdev": "comp_out0", "iothread": "iothread1", "vnet_hdr_support": vnet_hdr_support}
    colo_compare_arguments.update(colo_compare_options)
    qmp_execute(fd, [
        {"execute": "object-add", "arguments": {"qom-type": "iothread", "id": "iothread1"}},
        {"execute": "object-add", "arguments": colo_compare_arguments}
        ])

    # Start migration
    qmp_migrate_settings(fd, config)
    qmp_execute(fd, [
        {"exec-colod": "start-migration"},
        {"execute": "migrate", "arguments": {"uri": "tcp:%s:%s" % (ip, migrate_port())}}
        ])

def qmp_query_status(fd):
    return qmp_execute(fd, [{"exec-colod": "query-status"}])["return"]

def qmp_query_store(fd):
    return qmp_execute(fd, [{"exec-colod": "query-store"}])["return"]

def qmp_update_store(fd, update):
    store = qmp_query_store(fd)
    store.update(update)
    qmp_execute(fd, [{"exec-colod": "set-store", "store": store}])

def get_pid(pidfile):
    if not os.path.exists(pidfile):
        return None

    with open(pidfile, "r") as fd:
        pid = int(str.strip(fd.readline()))

    return pid

def pid_running(pidfile):
    if not os.path.exists(pidfile):
        return False

    pid = get_pid(pidfile)
    try:
        os.kill(pid, 0)
    except OSError:
        return False
    else:
        return True

def check_running_pid():
    return pid_running(QEMU_PIDFILE) or pid_running(COLOD_PIDFILE)

def new_peer(fd, peer):
    if qmp_query_store(fd)["peer"]:
        return

    qmp_start_resync(fd, peer)
    qmp_update_store(fd, {"peer": peer})
    qmp_execute(fd, [{"exec-colod": "clear-peer-status"}])
    # The secondary has inconsistent data until resync is finished
    set_remote_master_score(peer, 0)

def del_peer(fd):
    if qmp_check_resync(fd):
        qmp_cancel_resync(fd)
    qmp_update_store(fd, {"peer": None})

def qemu_colo_monitor():
    running = check_running_pid()
    if not running:
        return OCF_NOT_RUNNING

    fd = qmp_open()

    status = qmp_query_status(fd)
    if status["failed"]:
        log.error("qemu failed: %s" % status)
        return OCF_ERR_GENERIC

    if OCF_RESKEY_CRM_meta_interval != 0:
        if status["primary"]:
            # This isn't a probe monitor
            block_job = qmp_check_resync(fd)
            if block_job:
                if "error" in block_job:
                    log.error("resync error: %s" % block_job["error"])
                    peer = qmp_query_store(fd)["peer"]
                    del_peer(fd)
                    report_remote_failure(peer)

                elif status["peer-failed"]:
                    peer = qmp_query_store(fd)["peer"]
                    del_peer(fd)
                    report_remote_failure(peer)

                elif block_job["ready"]:
                    log.info("resync done, starting migration")
                    peer = qmp_query_store(fd)["peer"]
                    qmp_start_migration(fd, peer)

                else:
                    pct_done = (float(block_job["offset"]) \
                                / float(block_job["len"])) * 100
                    log.info("resync %.1f%% done" % pct_done)

        else: # Secondary
            if status["replication"]:
                if get_master_score() < 100:
                    set_master_score(100)

    pretend_secondary = qmp_query_store(fd)["pretend-secondary"]
    fd.close()

    if status["primary"] and not pretend_secondary:
        return OCF_RUNNING_MASTER
    else:
        return OCF_SUCCESS

def qemu_colo_start():
    if check_running_pid():
        log.info("qemu is already running")
        return OCF_SUCCESS

    config = parse_config(OCF_RESKEY_advanced_config)
    result = check_config(config)
    if result != OCF_SUCCESS:
        return result

    try:
        os.mkdir(BASE_DIR)
    except FileExistsError as e:
        pass

    rotate_logfile(QEMU_LOG, 8)
    rotate_logfile(QMP_LOG, 8)

    run_command(qemu_dummy_cmdline(config))
    run_command(colod_cmdline())
    fd = qmp_open()
    disk_size = qmp_get_disk_size(fd)
    fd.close()
    _qemu_colo_stop(False, False)

    run_command("'%s' create -q -f qcow2 %s %s" \
            % (OCF_RESKEY_qemu_img_binary, ACTIVE_IMAGE, disk_size))
    run_command("'%s' create -q -f qcow2 %s %s" \
            % (OCF_RESKEY_qemu_img_binary, HIDDEN_IMAGE, disk_size))

    run_command(qemu_secondary_cmdline(config))
    run_command(colod_cmdline())

    fd = qmp_open()
    qmp_setup_colod(fd)
    qmp_update_store(fd, {"pretend-secondary": True})
    qmp_throttle_settings(fd, config)
    qmp_migrate_settings(fd, config)
    qmp_execute(fd, [
        {"execute": "nbd-server-start", "arguments": {"addr": {"type": "inet", "data": {"host": str(OCF_RESKEY_listen_address), "port": str(nbd_port())}}}},
        {"execute": "nbd-server-add", "arguments": {"device": "parent0", "writable": True}},
        {"execute": "migrate-incoming", "arguments": {"uri": "tcp:%s:%s" % (OCF_RESKEY_listen_address, migrate_port())}}
        ])
    fd.close()

    return OCF_SUCCESS

def env_do_shutdown_guest():
    return OCF_RESKEY_CRM_meta_notify_active_uname \
           and OCF_RESKEY_CRM_meta_notify_stop_uname \
           and str.strip(OCF_RESKEY_CRM_meta_notify_active_uname) \
               == str.strip(OCF_RESKEY_CRM_meta_notify_stop_uname)

def env_find_secondary():
    # slave(s) =
    # OCF_RESKEY_CRM_meta_notify_slave_uname
    # - OCF_RESKEY_CRM_meta_notify_stop_uname
    # + OCF_RESKEY_CRM_meta_notify_start_uname
    # Filter out hosts that are stopping and ourselves
    for host in str.split(OCF_RESKEY_CRM_meta_notify_slave_uname, " "):
        if host:
            for stopping_host \
                in str.split(OCF_RESKEY_CRM_meta_notify_stop_uname, " "):
                if host == stopping_host:
                    break
            else:
                if host != HOSTNAME:
                    # we found a valid secondary
                    return host

    for host in str.split(OCF_RESKEY_CRM_meta_notify_start_uname, " "):
        if host != HOSTNAME:
            # we found a valid secondary
            return host

    # we found no secondary
    return None

def stop_qemu(failed, shutdown_guest):
    # stop action must do everything possible to stop the resource

    if not pid_running(QEMU_PIDFILE):
        log.info("resource is already stopped")
        return OCF_SUCCESS

    try:
        timeout = START_TIME + (OCF_RESKEY_CRM_meta_timeout*2/3/1000)

        if not failed:
            fd = qmp_open()

            if shutdown_guest:
                qmp_execute(fd, [{"execute": "system_powerdown"}])
                while time.time() < timeout:
                    running = pid_running(QEMU_PIDFILE)
                    if not running:
                        return OCF_SUCCESS

                    status = qmp_execute(fd, [{"execute": "query-status"}])
                    if status["return"]["status"] == "shutdown":
                        break
                    log.debug("Waiting for guest to shutdown")
                    time.sleep(1)

            qmp_execute(fd, [{"execute": "quit"}])
            fd.close()

            # wait for qemu to stop
            while time.time() < timeout:
                running = pid_running(QEMU_PIDFILE)
                if not running:
                    return OCF_SUCCESS

                log.debug("Waiting for qemu to stop")
                time.sleep(1)

            log.warning("clean stop timeout reached")
    except Exception as e:
        log.warning("error while stopping: %s" % e)

    running = pid_running(QEMU_PIDFILE)
    if not running:
        return OCF_SUCCESS

    log.info("force stopping qemu")

    pid = get_pid(QEMU_PIDFILE)
    try:
        if int(OCF_RESKEY_debug) >= 2:
            os.kill(pid, signal.SIGSEGV)
        else:
            os.kill(pid, signal.SIGTERM)
            time.sleep(2)
            os.kill(pid, signal.SIGKILL)
    except Exception:
        pass

    while pid_running(QEMU_PIDFILE):
        log.debug("Waiting for qemu to stop")
        time.sleep(1)

    return OCF_SUCCESS

def _qemu_colo_stop(failed, shutdown_guest):
    if pid_running(COLOD_PIDFILE):
        fd = qmp_open()
        qmp_execute(fd, [{"exec-colod": "autoquit"}])
        fd.close()

    result = stop_qemu(failed, shutdown_guest)

    while pid_running(COLOD_PIDFILE):
        log.debug("Waiting for colod to stop")
        time.sleep(1)

    return result

def calculate_master_score(status, shutdown_guest):
    primary = status["primary"]
    replication = status["replication"]
    failed = status["failed"]

    if shutdown_guest:
        if not primary and not replication:
            pass
        elif not primary and replication and not failed:
            set_master_score(10)
        elif not primary and replication and failed:
            set_master_score(0)
        elif primary and not replication:
            set_master_score(11)
        elif primary and replication and not failed:
            set_master_score(11)
        elif primary and replication and failed:
            set_master_score(0)
        else:
            raise Error()

    elif status["peer-failed"]:
        if not primary and not replication:
            pass
        elif not primary and replication:
            set_master_score(10)
        elif primary and not replication:
            set_master_score(11)
        elif primary and replication:
            set_master_score(11)
        else:
            raise Error()

    else:
        if not primary and not replication:
            pass
        elif not primary and replication:
            set_master_score(0)
        elif primary and not replication:
            set_master_score(11)
        elif primary and replication:
            set_master_score(0)
        else:
            raise Error()

def qemu_colo_stop():
    shutdown_guest = env_do_shutdown_guest()

    try:
        fd = qmp_open()
        status = qmp_query_status(fd)
        failed = status["failed"]
        fd.close()
    except Exception:
        status = None
        failed = True

    ret = _qemu_colo_stop(failed, shutdown_guest)

    if status:
        calculate_master_score(status, shutdown_guest)

    return ret

def qemu_colo_notify():
    fd = qmp_open()
    status = qmp_query_status(fd)
    fd.close()

    if status["failed"]:
        return OCF_ERR_GENERIC

    action = "%s-%s" % (OCF_RESKEY_CRM_meta_notify_type, \
                        OCF_RESKEY_CRM_meta_notify_operation)

    if action == "post-start":
        if status["primary"]:
            peer = str.strip(OCF_RESKEY_CRM_meta_notify_start_uname)
            fd = qmp_open()
            new_peer(fd, peer)
            fd.close()

    elif action == "pre-stop":
        if not env_do_shutdown_guest() \
           and (status["primary"] or status["replication"]) \
           and HOSTNAME != str.strip(OCF_RESKEY_CRM_meta_notify_stop_uname):
            fd = qmp_open()
            peer = qmp_query_store(fd)["peer"]
            log.debug("our peer: %s" % peer)
            if peer == str.strip(OCF_RESKEY_CRM_meta_notify_stop_uname):
                del_peer(fd)
            fd.close()

    elif action == "post-stop" \
         and OCF_RESKEY_CRM_meta_notify_key_operation == "stonith" \
         and (status["primary"] or status["replication"]):
        peer = str.strip(OCF_RESKEY_CRM_meta_notify_stop_uname)
        set_remote_master_score(peer, 0)

    return OCF_SUCCESS

def qemu_colo_promote():
    fd = qmp_open()
    status = qmp_query_status(fd)
    pretend_secondary = qmp_query_store(fd)["pretend-secondary"]
    fd.close()

    if status["failed"]:
        return OCF_ERR_GENERIC

    if not status["primary"] and not status["replication"]:
        config = parse_config(OCF_RESKEY_advanced_config)
        result = check_config(config)
        if result != OCF_SUCCESS:
            return result

        status = _qemu_colo_stop(False, False)
        if status != OCF_SUCCESS:
            return status

        rotate_logfile(QEMU_LOG, 8)
        rotate_logfile(QMP_LOG, 8)
        run_command(qemu_primary_cmdline(config))
        run_command(colod_cmdline() + " --primary")
        set_master_score(101)

        fd = qmp_open()
        qmp_setup_colod(fd)
        qmp_throttle_settings(fd, config)
        peer = env_find_secondary()
        if peer:
            new_peer(fd, peer)
        fd.close()

        return OCF_SUCCESS
    elif (status["primary"] or status["replication"]):
        fd = qmp_open()

        # Wait for promotion
        while not qmp_query_status(fd)["primary"]:
            log.debug("Waiting for promotion")
            time.sleep(1)

        qmp_update_store(fd, {"pretend-secondary": False})
        set_master_score(101)

        peer = env_find_secondary()
        if peer:
            new_peer(fd, peer)
        fd.close()
        return OCF_SUCCESS
    else:
        return OCF_ERR_GENERIC

def qemu_colo_demote():
    status = qemu_colo_stop()
    if status != OCF_SUCCESS:
        return status
    return qemu_colo_start()

if OCF_ACTION == "meta-data":
    qemu_colo_meta_data()
    exit(OCF_SUCCESS)

logs_open()

status = qemu_colo_validate_all()
# Exit here if our sanity checks fail, but try to continue if we need to stop
if status != OCF_SUCCESS and OCF_ACTION != "stop":
    exit(status)

try:
    if OCF_ACTION == "start":
        status = qemu_colo_start()
    elif OCF_ACTION == "stop":
        status = qemu_colo_stop()
    elif OCF_ACTION == "monitor":
        status = qemu_colo_monitor()
    elif OCF_ACTION == "notify":
        status = qemu_colo_notify()
    elif OCF_ACTION == "promote":
        status = qemu_colo_promote()
    elif OCF_ACTION == "demote":
        status = qemu_colo_demote()
    elif OCF_ACTION == "validate-all":
        status = qemu_colo_validate_all()
    else:
        status = OCF_ERR_UNIMPLEMENTED
except Exception as e:
    log.error(str(e))
    log.error(traceback.format_exec())
    exit(OCF_ERR_GENERIC)
else:
    exit(status)
